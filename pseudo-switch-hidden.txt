Pseudo-Switch

1. 	switch_hidden = function(x) {								# switch hidden takes input X.
2. 	Z = runif(1)												# set value  Z to a random value from a uniform distribution of 0 to 1.'

3a.	SUM = sum(hidden0[x,], hiddenf[x,],na.rm=TRUE)				# compute the sum of all elements of Data frames hidden0 & hiddenf on index x. Ignore invalids.
3b. if (SUM > 0) { 	# if hidden alleles exist					# If this sum is greater then 0, which implies that hidden alleles exist...

	4a.	hidden = c(hidden0[x,], hiddenf[x,])==1)					# combine the hidden0 and hiddenf elements
	4b.	match = which(hidden) > 1									# check elements which are equal to one.
	4a.	if ( length(match) > 0)										# check if the length of those elements are greater then 1. (If there is at least one match.)
		
		5.	chosen = sample(which(c(hidden0[x,], hiddenf[x,])==1),1)	# If so, Set the chosen to [1] random item in the which hidden vector.

	6.	else														# else,
		7.	chosen = which(c(hidden0[x,], hiddenf[x,])==1)				# Set chosen to the [1] mask of the hidden values equal to one.

	9.	if (classification[x] == 0) { # reinfection					# If classified as a reinfection....
		10. if (chosen <= nloci*maxMOI) { # day 0 hidden alleles 		# If chosen is less then nloci * maxMOI
			11. chosenlocus = ceiling(chosen/maxMOI)						# chosenlocus is the RoundedUp of (chosen/maxMOI)
			12. old = recoded0[x,chosen]									# old is redcoded0[x,chosen]
			13. new = sample(1:frequencies_RR[[1]][chosenlocus],1)			# (Double brackets??) new is a sample from the list of whole integers from 1 to freq()

			16a. oldalleles = 												# oldalleles is 
			16b. recoded0[x,intersection]									# 	the xth row of recoded0, and 
			16c. intersection = intersect(sequence,mask)					# 	the intersection of a sequence of indicies to a mask...
			16d. mask = which(hidden0[x,] == 0)								# 	... of the columns of row x that are equal to zero.
			16d. start = ((chosenlocus-1)*maxMOI+1)							#   start sequence at 
			16e. stop =	((chosenlocus)*maxMOI)								#   stop sequence at
			16f. sequence = start:stop										#   sequence goes from start to stop.

			17. repeatedold = qq											# repeated old is qq (what is qq?)
			18. repeatednew = qq											# repeated new is qq (what is qq?)
			19. if (sum(oldalleles == old) >= 1)							# if the sum of the mask of matched elements in oldalleles and old is at least one (if there is at least one match)
				20. repeatold = 1											# 	repeatold is 1.
			21. if (sum(oldalleles == new) >= 1)							# if the sum of the mask of matched elements in oldalleles and new is at least one (if there is at least one match)
				23. repeatedold = 1											#	repeatnew is 1.

			# HUGE LINE!!!
			alpha = (sum(frequencies_RR[[2]][chosenlocus,1:frequencies_RR[[1]][chosenlocus]]*dvect[correction_distance_matrix[[chosenlocus]][,new]+1]) * repeatednew) / 
				(sum(frequencies_RR[[2]][chosenlocus,1:frequencies_RR[[1]][chosenlocus]]*dvect[correction_distance_matrix[[chosenlocus]][,old]+1]) * repeatedold)

			25a. subFreqTable2 = frequencies_RR[2]											# Is this a subtable?
			25b. selectedColumns = 1:frequencies_RR[1][chosenlocus]
			25c. subSection = subFreqTable2[chosenlocus,selectedColumns]					# What actually is 'subSection?'
			25d. newDistancesVector = dvect[correction_distance[chosenlocus][,new] + 1]		# Why the plus one?
			25e. newSum = sum(repeatednew * newDistanceVector * subSection)
			25f. oldDistancesVector = dvect[correction_distance[chosenlocus][,new] + 1]		# Again, why the plus one?
			25g. oldSum = sum(repeatedold * oldDistanceVector * subSection)
			25h. alpha = newSum / oldSum													# This alpha, check the notes for its meaning.

			26. if (Z > alpha)																# if random value Z is greater than alpha (Okay, so alpha is the learning rate then?)
				27.recodedf[x,chosen] <<- new 													# superassign recodedf, row x, column chosen, as new. (Why super assign? Setting a global var?)


				newallele_length = mean(alleles_definitions_RR[[chosenlocus]][new,]) + rnorm(1,mean=0,sd=frequencies_RR[[3]][chosenlocus])

				28a. alleleDefSubTable = alleles_definitions_RR[[chosenlocus]]
				28b. allelesNewRow = alleleDefSubTable[new,]
				28c. meanAlleleLength = mean(allelesNewRow)
				28d. standardDev = frequencies_RR[3][chosenlocus] 								# take the standard deviation of this allele from freqRR table 3, at the chosenlocus
				28e. randomNormal = rnorm(1, mean=0, sd = standardDev)
				28f. newallele_length = meanAlleleLength + randomNormal							# Semi-Random new Allele Length generated.

				29. alleles0[x,chosen] <<- newallele_length										# record the allele length at row x, column chosen.
				42. allpossiblerecrud = expand.grid(1:MOI0[x],1:MOIf[x])						# create a table to represent all possible recrudesnces.

				# at this point, some variables are divined using methods I don't quite understand.

				# I feel these all should become functions that act on inputs.
				closestrecrud = which.min(sapply(1:dim(allpossiblerecrud)[1], function (y) abs(alleles0[x,maxMOI*(chosenlocus-1)+allpossiblerecrud[y,1]] - allelesf[x,maxMOI*(chosenlocus-1)+allpossiblerecrud[y,2]])))

				43a. commonPart = maxMOI * (chosenlocus - 1)									# common component of the columns to be calculated.
				43b. col_1 = commonPart + allpossiblerecrud[y,1]								# column to be selected from alleles0
				43c. col_2 = commonPart + allpossiblerecrud[y,2]								# column to be selected from allelesf
				43d. diff = alleles0[x, col_1] - allelesf[x, col_2]								# difference between two alleles
				43e. function distance(y) { abs(diff) };										# distance in a single dimension.
				43f. seq = 1:dim(allpossiblerecrud)[1]											# sequence of numbers from 1 whatever the length of the first dimension of all possiblerecrud is.
				43g. appliedDistance = sapply(seq,distance)										# the result of applying the distance function to all values within sequence.
				43h. closestrecrud = which.min( appliedDistance )								# select the INDEX of the smallest distance value (That's what it seems to be in context.)

				# Looks like we're recalculating a lot of what we already know at this point.
				# What exactly is happening is hard to grasp, but it seems we're saving values calculated?

				mindistance[x,chosenlocus] <<- abs(alleles0[x,maxMOI*(chosenlocus-1)+allpossiblerecrud[closestrecrud,1]] - allelesf[x,maxMOI*(chosenlocus-1)+allpossiblerecrud[closestrecrud,2]])

				# But all this is just the function we defined earlier no?
				44. minDistance[x,chosenlocus] <<- distance(closestrecrud)						# What is the importance of the '<<-' operator? would '=' suffice?

				# Now this is a big line lol.
				# alldistance[x,chosenlocus,1:dim(allpossiblerecrud)[1]] <<- sapply(1:dim(allpossiblerecrud)[1], function (y) abs(alleles0[x,maxMOI*(chosenlocus-1)+allpossiblerecrud[y,1]] - allelesf[x,maxMOI*(chosenlocus-1)+allpossiblerecrud[y,2]]))

				# Question:
				# alldistance appears to be a 3 Dimensional structure of sorts. What does it represent? The distance between any two possible alleles?
				# that cant be right, such a table would only require 2 dimensions. Perhaps between possible alleles of a certain gene, x?

				# Either way, seems we are saving results we already calculated up in line 43 again.
				45. alldistance[x,chosenlocus,seq] <<- appliedDistance							# save all distance calculations.

				# This is a new operation it seems, but the indicies should be familiar.
				allrecrf[x,chosenlocus,1:dim(allpossiblerecrud)[1]] <<- recodedf[x,maxMOI*(chosenlocus-1)+allpossiblerecrud[,2]]

				46a. recrudCol2 = commonPart + +allpossiblerecrud[,2]							# We seem to be using a vector for our index in recodedf.
				46b. allrecrf[x,chosenlocus,seq] <<- recodedf[x,recrudCol2] 					# How large are these vector indicies? What is happening here?

				47. recr0[x,chosenlocus] <<- commonPart + allpossiblerecrud[closestrecrud,1]	# Save a recrudesence to the recr0 table. Why?
				48. recrf[x,chosenlocus] <<- commonPart + allpossiblerecrud[closestrecrud,2]	# Same deal, but with the recrf table.

				# Back to being complex again it seems. Looks like we're gonna count repetitions?
				# WARNING: LANGUAGE SPECIFIC IMPLEMENTATION!
				# Indicies here are actually not precalculated, so this is gonna be a little tougher.
				# Concerned about the calculation of the END component of the sequence. Seems like
				# The OG program was taking advantage of R's indexing beginning at 1. This same trick
				# will NOT work with Python's indexing if so.

				recr_repeats0[x,chosenlocus] <<- sum(recoded0[x,(maxMOI*(chosenlocus-1)+1) : (maxMOI*(chosenlocus))] == recoded0[x,recr0[x,chosenlocus]])

				49a. starting = commonPart + 1													# starting location of our index vector. (language specific!)
				49b. ending = maxMOI * chosenlocus 												# ending location of our index vector (This is gonna be a BIG BOY problem.)
				49c. seq = starting : ending													# Sequence representing our indicies of interest in recoded0.
				49d. recrudVector = recr0[x,chosenlocus]										# Some kind of vector (I think...?) representing recrudesent values.
				49d. recr_repeats0[x,chosenlocus] <<- sum(recoded0[x,seq] == recoded0[x,recrudVector])					# Counts the number of values that matched in the mask of the equivalency check.

				# similar process, but for recr_repeatsf. Index math is almost the same.
				recr_repeatsf[x,chosenlocus] <<- sum(recodedf[x,(maxMOI*(chosenlocus-1)+1) : (maxMOI*(chosenlocus))] == recodedf[x,recrf[x,chosenlocus]])

				50a. recrudVector = recrf[x,chosenlocus]										# Sequence representing our indicies of interest in recodedf.
				50b. recr_repeatsf[x,chosenlocus] <<- sum(recodedf[x,seq] == recodedf[x,recrudVector])					# Counts the number of values that matched in the mask of the equivalency check.

		53. else 																		# alternate for if on line 10.
			# Pretty much the same as lines 11-16.
			# Suggestion: Convert those lines into a builder pattern obj. Then call else there
			# and pass either recoded0 or recodedf depending on the condition.
			# For now, I only translate those lines, everything else seems the same.

			54. chosen = chosen - nloci * maxMOI											# chosen is slightly different on this branch.
			55. chosenlocus = ceiling(chosen/maxMOI)										# chosenlocus is the RoundedUp of (chosen/maxMOI)
			56. old = recodedf[x,chosen]													# old is redcodedf[x,chosen]
			57. new = sample(1:frequencies_RR[[1]][chosenlocus],1)							# Litteral copy paste of line 13.

			# Looks like line 16.
			oldalleles = recodedf[x,intersect(((chosenlocus-1)*maxMOI+1):((chosenlocus)*maxMOI),which(hiddenf[x,] == 0))]

			58a. oldalleles = 																# oldalleles is 
			58b. recodedf[x,intersection]													# 	the xth row of recoded0, and 
			58c. intersection = intersect(sequence,mask)									# 	the intersection of a sequence of indicies to a mask...
			58d. mask = which(hidden0[x,] == 0)												# 	... of the columns of row x that are equal to zero.
			58d. start = ((chosenlocus-1)*maxMOI+1)											#   start sequence at 
			58e. stop =	((chosenlocus)*maxMOI)												#   stop sequence at
			58f. sequence = start:stop														#   sequence goes from start to stop.

			# Everything past this seems to mirror the if statement, so I'll skip it.

	59. else 																		# classification is NOT 0.
	















