Pseudo-Switch

1. 	switch_hidden = function(x) {								# switch hidden takes input X.
2. 	Z = runif(1)												# set value  Z to a random value from a uniform distribution of 0 to 1.'

3a.	SUM = sum(hidden0[x,], hiddenf[x,],na.rm=TRUE)				# compute the sum of all elements of Data frames hidden0 & hiddenf on index x. Ignore invalids.
3b. if (SUM > 0) { 	# if hidden alleles exist					# If this sum is greater then 0, which implies that hidden alleles exist...

	4a.	hidden = c(hidden0[x,], hiddenf[x,])==1)					# combine the hidden0 and hiddenf elements
	4b.	match = which(hidden) > 1									# check elements which are equal to one.
	4a.	if ( length(match) > 0)										# check if the length of those elements are greater then 1. (If there is at least one match.)
		
		5.	chosen = sample(which(c(hidden0[x,], hiddenf[x,])==1),1)	# If so, Set the chosen to [1] random item in the which hidden vector.

	6.	else														# else,
		7.	chosen = which(c(hidden0[x,], hiddenf[x,])==1)				# Set chosen to the [1] mask of the hidden values equal to one.

	9.	if (classification[x] == 0) { # reinfection					# If classified as a reinfection....
		10. if (chosen <= nloci*maxMOI) { # day 0 hidden alleles 		# If chosen is less then nloci * maxMOI
			11. chosenlocus = ceiling(chosen/maxMOI)						# chosenlocus is the RoundedUp of (chosen/maxMOI)
			12. old = recoded0[x,chosen]									# old is redcoded0[x,chosen]
			13. new = sample(1:frequencies_RR[[1]][chosenlocus],1)			# (Double brackets??) new is a sample from the list of whole integers from 1 to freq()

			16a. oldalleles = 												# oldalleles is 
			16b. recoded0[x,intersection]									# 	the xth row of recoded0, and 
			16c. intersection = intersect(sequence,mask)					# 	the intersection of a sequence of indicies to a mask...
			16d. mask = which(hidden0[x,] == 0)								# 	... of the columns of row x that are equal to zero.
			16d. start = ((chosenlocus-1)*maxMOI+1)							#   start sequence at 
			16e. stop =	((chosenlocus)*maxMOI)								#   stop sequence at
			16f. sequence = start:stop										#   sequence goes from start to stop.

			17. repeatedold = qq											# repeated old is qq (what is qq?)
			18. repeatednew = qq											# repeated new is qq (what is qq?)
			19. if (sum(oldalleles == old) >= 1)							# if the sum of the mask of matched elements in oldalleles and old is at least one (if there is at least one match)
				20. repeatold = 1											# 	repeatold is 1.
			21. if (sum(oldalleles == new) >= 1)							# if the sum of the mask of matched elements in oldalleles and new is at least one (if there is at least one match)
				23. repeatedold = 1											#	repeatnew is 1.

			# HUGE LINE!!!
			alpha = (sum(frequencies_RR[[2]][chosenlocus,1:frequencies_RR[[1]][chosenlocus]]*dvect[correction_distance_matrix[[chosenlocus]][,new]+1]) * repeatednew) / 
				(sum(frequencies_RR[[2]][chosenlocus,1:frequencies_RR[[1]][chosenlocus]]*dvect[correction_distance_matrix[[chosenlocus]][,old]+1]) * repeatedold)

			25a. subFreqTable2 = frequencies_RR[2]											# Is this a subtable?
			25b. selectedColumns = 1:frequencies_RR[1][chosenlocus]
			25c. subSection = subFreqTable2[chosenlocus,selectedColumns]					# What actually is 'subSection?'
			25d. newDistancesVector = dvect[correction_distance[chosenlocus][,new] + 1]		# Why the plus one?
			25e. newSum = sum(repeatednew * newDistanceVector * subSection)
			25f. oldDistancesVector = dvect[correction_distance[chosenlocus][,new] + 1]		# Again, why the plus one?
			25g. oldSum = sum(repeatedold * oldDistanceVector * subSection)
			25h. alpha = newSum / oldSum													# This alpha, check the notes for its meaning.

			26. if (Z > alpha)																# if random value Z is greater than alpha (Okay, so alpha is the learning rate then?)
				27.recodedf[x,chosen] <<- new 													# superassign recodedf, row x, column chosen, as new. (Why super assign? Setting a global var?)


				newallele_length = mean(alleles_definitions_RR[[chosenlocus]][new,]) + rnorm(1,mean=0,sd=frequencies_RR[[3]][chosenlocus])

				28a. alleleDefSubTable = alleles_definitions_RR[[chosenlocus]]
				28b. allelesNewRow = alleleDefSubTable[new,]
				28c. meanAlleleLength = mean(allelesNewRow)
				28d. standardDev = frequencies_RR[3][chosenlocus] 								# take the standard deviation of this allele from freqRR table 3, at the chosenlocus
				28e. randomNormal = rnorm(1, mean=0, sd = standardDev)
				28f. newallele_length = meanAlleleLength + randomNormal							# Semi-Random new Allele Length generated.

				29. alleles0[x,chosen] <<- newallele_length										# record the allele length at row x, column chosen.
				42. allpossiblerecrud = expand.grid(1:MOI0[x],1:MOIf[x])						# create a table to represent all possible recrudesnces.

				# at this point, some variables are divined using methods I don't quite understand.

				# I feel these all should become functions that act on inputs.
				closestrecrud = which.min(sapply(1:dim(allpossiblerecrud)[1], function (y) abs(alleles0[x,maxMOI*(chosenlocus-1)+allpossiblerecrud[y,1]] - allelesf x,maxMOI*(chosenlocus-1)+allpossiblerecrud[y,2]])))

				43a. commonPart = maxMOI * (chosenlocus - 1)									# common component of the columns to be calculated.
				43b. col_1 = commonPart + allpossiblerecrud[y,1]								# column to be selected from alleles0
				43c. col_2 = commonPart + allpossiblerecrud[y,2]								# column to be selected from allelesf
				43d. diff = alleles0[x, col_1] - allelesf[x, col_2]								# difference between two alleles
				43e. function distance(y) { abs(diff) };										# distance in a single dimension.
				43f. seq = 1:dim(allpossiblerecrud)[1]											# sequence of numbers from 1 whatever the length of the first dimension of all possiblerecrud is.
				43g. appliedDistance = sapply(seq,distance)										# the result of applying the distance function to all values within sequence.
				43h. closestrecrud = which.min( appliedDistance )								# select the INDEX of the smallest distance value (That's what it seems to be in context.)

				# Looks like we're recalculating a lot of what we already know at this point.
				# What exactly is happening is hard to grasp, but it seems we're saving values calculated?

				mindistance[x,chosenlocus] <<- abs(alleles0[x,maxMOI*(chosenlocus-1)+allpossiblerecrud[closestrecrud,1]] - allelesf[x,maxMOI*(chosenlocus-1)+allpossiblerecrud[closestrecrud,2]])

				# But all this is just the function we defined earlier no?
				44. minDistance[x,chosenlocus] <<- distance(closestrecrud)						# What is the importance of the '<<-' operator? would '=' suffice?

				# Now this is a big line lol.
				# alldistance[x,chosenlocus,1:dim(allpossiblerecrud)[1]] <<- sapply(1:dim(allpossiblerecrud)[1], function (y) abs(alleles0[x,maxMOI*(chosenlocus-1)+allpossiblerecrud[y,1]] - allelesf[x,maxMOI*(chosenlocus-1)+allpossiblerecrud[y,2]]))

				# Question:
				# alldistance appears to be a 3 Dimensional structure of sorts. What does it represent? The distance between any two possible alleles?
				# that cant be right, such a table would only require 2 dimensions. Perhaps between possible alleles of a certain gene, x?

				# Either way, seems we are saving results we already calculated up in line 43 again.
				45. alldistance[x,chosenlocus,seq] <<- appliedDistance							# save all distance calculations.

				# This is a new operation it seems, but the indicies should be familiar.
				allrecrf[x,chosenlocus,1:dim(allpossiblerecrud)[1]] <<- recodedf[x,maxMOI*(chosenlocus-1)+allpossiblerecrud[,2]]

				46a. recrudCol2 = commonPart + +allpossiblerecrud[,2]							# We seem to be using a vector for our index in recodedf.
				46b. allrecrf[x,chosenlocus,seq] <<- recodedf[x,recrudCol2] 					# How large are these vector indicies? What is happening here?

				47. recr0[x,chosenlocus] <<- commonPart + allpossiblerecrud[closestrecrud,1]	# Save a recrudesence to the recr0 table. Why?
				48. recrf[x,chosenlocus] <<- commonPart + allpossiblerecrud[closestrecrud,2]	# Same deal, but with the recrf table.

				# Back to being complex again it seems. Looks like we're gonna count repetitions?
				# WARNING: LANGUAGE SPECIFIC IMPLEMENTATION!
				# Indicies here are actually not precalculated, so this is gonna be a little tougher.
				# Concerned about the calculation of the END component of the sequence. Seems like
				# The OG program was taking advantage of R's indexing beginning at 1. This same trick
				# will NOT work with Python's indexing if so.

				recr_repeats0[x,chosenlocus] <<- sum(recoded0[x,(maxMOI*(chosenlocus-1)+1) : (maxMOI*(chosenlocus))] == recoded0[x,recr0[x,chosenlocus]])

				49a. starting = commonPart + 1													# starting location of our index vector. (language specific!)
				49b. ending = maxMOI * chosenlocus 												# ending location of our index vector (This is gonna be a BIG BOY problem.)
				49c. seq = starting : ending													# Sequence representing our indicies of interest in recoded0.
				49d. recrudVector = recr0[x,chosenlocus]										# Some kind of vector (I think...?) representing recrudesent values.
				49d. recr_repeats0[x,chosenlocus] <<- sum(recoded0[x,seq] == recoded0[x,recrudVector])					# Counts the number of values that matched in the mask of the equivalency check.

				# similar process, but for recr_repeatsf. Index math is almost the same.
				recr_repeatsf[x,chosenlocus] <<- sum(recodedf[x,(maxMOI*(chosenlocus-1)+1) : (maxMOI*(chosenlocus))] == recodedf[x,recrf[x,chosenlocus]])

				50a. recrudVector = recrf[x,chosenlocus]										# Sequence representing our indicies of interest in recodedf.
				50b. recr_repeatsf[x,chosenlocus] <<- sum(recodedf[x,seq] == recodedf[x,recrudVector])					# Counts the number of values that matched in the mask of the equivalency check.

		53. else 																		# alternate for if on line 10.
			# Pretty much the same as lines 11-16.
			# Suggestion: Convert those lines into a builder pattern obj. Then call else there
			# and pass either recoded0 or recodedf depending on the condition.
			# For now, I only translate those lines, everything else seems the same.

			54. chosen = chosen - nloci * maxMOI											# chosen is slightly different on this branch.
			55. chosenlocus = ceiling(chosen/maxMOI)										# chosenlocus is the RoundedUp of (chosen/maxMOI)
			56. old = recodedf[x,chosen]													# old is redcodedf[x,chosen]
			57. new = sample(1:frequencies_RR[[1]][chosenlocus],1)							# Litteral copy paste of line 13.

			# Looks like line 16.
			oldalleles = recodedf[x,intersect(((chosenlocus-1)*maxMOI+1):((chosenlocus)*maxMOI),which(hiddenf[x,] == 0))]

			58a. oldalleles = 																# oldalleles is 
			58b. recodedf[x,intersection]													# 	the xth row of recoded0, and 
			58c. intersection = intersect(sequence,mask)									# 	the intersection of a sequence of indicies to a mask...
			58d. mask = which(hidden0[x,] == 0)												# 	... of the columns of row x that are equal to zero.
			58d. start = ((chosenlocus-1)*maxMOI+1)											#   start sequence at 
			58e. stop =	((chosenlocus)*maxMOI)												#   stop sequence at
			58f. sequence = start:stop														#   sequence goes from start to stop.

			# Everything past this seems to mirror the if statement, so I'll skip it.

	59. else 																		# classification is NOT 0.
		60. if (chosen <= nloci * maxMOI)												# (Same as in non-branching path, beginning at line 10.)
			61. chosenlocus = ceiling(chosen/maxMOI)										# ditto
			62. old = recoded0[x,chosen]													# ditto
			63. new = sample(1:frequencies_RR[[1]][chosenlocus],1)							# ditto

			#New line.
			newallele_length = mean(alleles_definitions_RR[[chosenlocus]][new,]) + rnorm(1,mean=0,sd=frequencies_RR[[3]][chosenlocus])

			64a. allele_defs = alleles_definitions_RR[[chosenlocus]][new,]					 # 
			64b. standard_dev = frequencies_RR[[3]][chosenlocus]							 #
			64c. newallele_length = mean(allele_defs) + rnorm(1,mean = 0, sd = standard_dev) #

			# same as line 16.
			oldalleles = recoded0[x,intersect(((chosenlocus-1)*maxMOI+1):((chosenlocus)*maxMOI),which(hidden0[x,] == 0))]

			114a. oldalleles = 																# oldalleles is 
			114b. recoded0[x,intersection]													# 	the xth row of recoded0, and 
			114c. intersection = intersect(sequence,mask)									# 	the intersection of a sequence of indicies to a mask...
			114d. mask = which(hidden0[x,] == 0)											# 	... of the columns of row x that are equal to zero.
			114d. start = ((chosenlocus-1)*maxMOI+1)										#   start sequence at 
			114e. stop =	((chosenlocus)*maxMOI)											#   stop sequence at
			114f. sequence = start:stop														#   sequence goes from start to stop.

			115. repeatedold = qq											
			116. repeatednew = qq
			117. if (sum(oldalleles == old) >= 1) # if old allele is a repeat, don't penalize with missing probability
				118.	repeatedold = 1;
			120. if (sum(oldalleles == new) >= 1) # if new allele is a repeat, don't penalize with missing probability
				121.	repeatednew = 1;

			122. allpossiblerecrud = expand.grid(1:MOI0[x],1:MOIf[x])						# Creates a new Data Frame. (But of what shape?)
			123a. starting = maxMOI * (chosenlocus - 1) + 1
			123b. ending = maxMOI
			123c. seq = starting:ending
			123b. tempalleles = alleles0[x,seq]

			124a. index = chosen-(chosenlocus-1) * maxMOI
			124b. tempalleles[index] = newallele_length 	

			125. temprecoded = recoded0[x,seq]
			126. temprecoded[index] = new

			# Looks SIMILAR to Line 43, but with a slight difference (tempalleles instead of alleles0).
			newclosestrecrud = which.min(sapply(1:dim(allpossiblerecrud)[1], function (y) abs(tempalleles[allpossiblerecrud[y,1]] - allelesf[x,maxMOI*(chosenlocus-1)+allpossiblerecrud[y,2]])))

			129a. commonPart = maxMOI * (chosenlocus - 1)									# common component of the columns to be calculated.
			129b. col_1 = commonPart + allpossiblerecrud[y,1]								# column to be selected from tempalleles
			129c. col_2 = commonPart + allpossiblerecrud[y,2]								# column to be selected from allelesf
			129d. diff = tempalleles[x, col_1] - allelesf[x, col_2]							# difference between two alleles
			129e. function distance(y) { abs(diff) };										# distance in a single dimension.
			129f. seq = 1:dim(allpossiblerecrud)[1]											# sequence of numbers from 1 whatever the length of the first dimension of all possiblerecrud is.
			129g. appliedDistance = sapply(seq,distance)									# the result of applying the distance function to all values within sequence.
			129h. newclosestrecrud = which.min( appliedDistance )							# select the INDEX of the smallest distance value (That's what it seems to be in context.)

			# Again, pretty familiar, no?
			newmindistance = abs(tempalleles[allpossiblerecrud[newclosestrecrud,1]] - allelesf[x,maxMOI*(chosenlocus-1)+allpossiblerecrud[newclosestrecrud,2]])

			130. newmindistance = distance(newclosestrecrud)								# Save the minimum distance.						

			# Once again!
			newalldistance = sapply(1:dim(allpossiblerecrud)[1], function (y) abs(tempalleles[allpossiblerecrud[y,1]] - allelesf[x,maxMOI*(chosenlocus-1)+allpossiblerecrud[y,2]]))

			131. newallDistance = appliedDistance											# Save all distances.
			132. newallrecrf = temprecoded[allpossiblerecrud[,2]]							# record the temprecord results into a variable named newallrecrf.

			# calculate new multiple-comparisons coefficient

			135. newrecr0 = commonPart + allpossiblerecrud[newclosestrecrud,1]
			136. newrecrf = commonPart + allpossiblerecrud[newclosestrecrud,2]

			137a. indicies = allpossiblerecrud[newclosestrecrud,1]
			137b. newrecr_repeats0 = sum(temprecoded == temprecoded[indicies],na.rm=TRUE)	# Find locations where tempcoded matches...?... without matching non-numerical values.

			138a. seq = (commonPart + 1) : (maxMOI*(chosenlocus))							# Define a sequence of locations to check for matches.
			138b. newrecr_repeatsf = sum(recodedf[x,seq] == recodedf[x,newrecrf])			# Find the matches..?

			# Absolutely massive line to calculate what I assume is a likelihood of the new value for the alleles?
			likelihoodnew = mean(dvect[round(newalldistance)+1]/sapply(1:length(newallrecrf), function (z) sum(frequencies_RR[[2]][chosenlocus,1:frequencies_RR[[1]][chosenlocus]]*dvect[correction_distance_matrix[[chosenlocus]][,newallrecrf[z]]+1])),na.rm=TRUE) * repeatednew

			141a. likelihoodnew = mean(bigPhrase, na.rm=TRUE) * repeatednew
			141b. dvector = dvect[ round(newalldistance)+1 ]
			141c. seq = 1:length(newallrecrf)
			141d. function unknownProcess (lambda){
				table = frequencies_RR[[2]]
				freq_seq = 1:frequencies_RR[[1]][chosenlocus]
				table = table[chosenlocus, freq_seq]
				sub_index = correction_distance_matrix[[chosenlocus]][,newallrecrf[lambda]]+1
				dvect[sub_index]
				return table * dvect
			}

			# Absolutely massive line to calculate what I assume is a likelihood of the old value for the alleles? only difference is the use of allrecrf
			likelihoodold = mean(dvect[round(alldistance[x,chosenlocus,])+1]/sapply(1:(maxMOI*maxMOI), function (z) sum(frequencies_RR[[2]][chosenlocus,1:frequencies_RR[[1]][chosenlocus]]*dvect[correction_distance_matrix[[chosenlocus]][,allrecrf[x,chosenlocus,z]]+1])),na.rm=TRUE) * repeatedold

			143a. likelihoodnew = mean(bigPhrase, na.rm=TRUE) * repeatedold
			143b. dvector = dvect[ round(newalldistance)+1 ]
			143c. seq = 1:length(newallrecrf)
			143d. function unknownProcess2 (lambda){
				table = frequencies_RR[[2]]
				freq_seq = 1:frequencies_RR[[1]][chosenlocus]
				table = table[chosenlocus, freq_seq]
				sub_index = correction_distance_matrix[[chosenlocus]][,allrecrf[lambda]]+1
				dvect[sub_index]
				return table * dvect
			}

			# code I didn't translate, just for debug purposes. Might add to the debug obj if really necessary.
			if (is.na(likelihoodnew) | is.na(likelihoodold)) { # debug
				write.csv(alleles0,"alleles0.csv")
				write.csv(allelesf,"allelesf.csv")
				write.csv(hidden0,"hidden0.csv")
				write.csv(hiddenf,"hiddenf.csv")
				write.csv(dvect,"dvect.csv")
				print(chosen)
				print(chosenlocus)
				print(chosenlocus)
				print(old)
				print(new)
				print(newallele_length)
				print(tempalleles)
				write.csv(newalldistance,"newalldistance.csv")
				write.csv(alldistance,"alldistance.csv")
			}

			144. if (likelihoodnew  == likelihoodold) {
				145. alpha = 1										# if both num and denominator are equal (for case when both are 0..., otherwise 0/0 gives NaN)						 
			146. else
				147. alpha = likelihoodnew / likelihoodold			# Otherwise, calculate what appears to be a ratio. Why not a probability (0 to 1) ?

			148. if (z < alpha)										# switch made
				149. recoded0[x,chosen] <<- new
				150. alleles0[x,chosen] <<- newallele_length
				151. mindistance[x,chosenlocus] <<- newmindistance

				152a. seq = 1:dim(allpossiblerecrud)[1]
				152b. alldistance[x,chosenlocus,seq] <<- newalldistance

				153. allrecrf[x,chosenlocus,seq] <<- newallrecrf
				154. recr0[x,chosenlocus] <<- commonPart + allpossiblerecrud[newclosestrecrud,1]
				155. recrf[x,chosenlocus] <<- commonPart + allpossiblerecrud[newclosestrecrud,2]

				156a. seq = (commonPart + 1) : (maxMOI*(chosenlocus))
				156b. recr_repeats0[x,chosenlocus] <<- sum(recoded0[x,seq] == recoded0[x,recr0[x,chosenlocus]])

				157. recr_repeatsf[x,chosenlocus] <<- sum(recodedf[x,seq] == recodedf[x,recrf[x,chosenlocus]])
		158. else
			# Similarly to before , I suspect this branch doesn't actually differ that much from the previous one.
			181. chosen = chosen - nloci*maxMOI												# new line
			182. chosenlocus = ceiling(chosen/maxMOI)										# rewrite
			183. old = recodedf[x,chosen]													# rewrite
			184. new = sample(1:frequencies_RR[[1]][chosenlocus],1)	 						# rewrite
				
			185a. allele_defs = alleles_definitions_RR[[chosenlocus]][new,]					 	# 
			185b. standard_dev = frequencies_RR[[3]][chosenlocus]							 	#
			185c. newallele_length = mean(allele_defs) + rnorm(1,mean = 0, sd = standard_dev) 	#

			# Slight difference from 114, mostly including f tables instead of 0 tables.
			oldalleles = recodedf[x,intersect(((chosenlocus-1)*maxMOI+1):((chosenlocus)*maxMOI),which(hiddenf[x,] == 0))]

			186a. oldalleles = 																# oldalleles is 
			186b. recodedf[x,intersection]													# 	the xth row of recoded0, and 
			186c. intersection = intersect(sequence,mask)									# 	the intersection of a sequence of indicies to a mask...
			186d. mask = which(hiddenf[x,] == 0)											# 	... of the columns of row x that are equal to zero.
			186d. start = ((chosenlocus-1)*maxMOI+1)										#   start sequence at 
			186e. stop =	((chosenlocus)*maxMOI)											#   stop sequence at
			186f. sequence = start:stop														#   sequence goes from start to stop.

			187. allpossiblerecrud = expand.grid(1:MOI0[x],1:MOIf[x])						# Creates a new Data Frame. (But of what shape?)
			188a. starting = maxMOI * (chosenlocus - 1) + 1									# Indexing stuff is the same across both branches.
			188b. ending = maxMOI
			188c. seq = starting:ending
			188b. tempalleles = allelesf[x,seq]												# tempalleles is generated from allelesf instead of alleles0.

			189a. index = chosen-(chosenlocus-1) * maxMOI									# Completely the same.
			189b. tempalleles[index] = newallele_length 	

			190. temprecoded = recodedf[x,seq]												# Use allelesf instead of alleles0.
			191. temprecoded[index] = new

			# Same as 129. Only difference is the second index used in the allpossiblecrud call in the unknown function. (Which should NOT change anything, I think?)
			newclosestrecrud = which.min(sapply(1:dim(allpossiblerecrud)[1], function (y) abs(tempalleles[allpossiblerecrud[y,2]] - alleles0[x,maxMOI*(chosenlocus-1)+allpossiblerecrud[y,1]])))

			208a. commonPart = maxMOI * (chosenlocus - 1)									# common component of the columns to be calculated.
			208b. col_1 = commonPart + allpossiblerecrud[y,2]								# column to be selected from tempalleles
			208c. col_2 = commonPart + allpossiblerecrud[y,1]								# column to be selected from allelesf
			208d. diff = tempalleles[x, col_1] - allelesf[x, col_2]							# difference between two alleles
			208e. function distance(y) { abs(diff) };										# distance in a single dimension.
			208f. seq = 1:dim(allpossiblerecrud)[1]											# sequence of numbers from 1 whatever the length of the first dimension of all possiblerecrud is.
			208g. appliedDistance = sapply(seq,distance)									# the result of applying the distance function to all values within sequence.
			208h. newclosestrecrud = which.min( appliedDistance )							# select the INDEX of the smallest distance value (That's what it seems to be in context.)

			# Again, only differences here were column swaps (implemented in 208 above.)

			209. newmindistance = distance(newclosestrecrud)								# Save the minimum distance.						
			210. newallDistance = appliedDistance											# Save all distances.
			211. newallrecrf = temprecoded[allpossiblerecrud[,2]]							# record the temprecord results into a variable named newallrecrf.

			# Same

			214. newrecr0 = commonPart + allpossiblerecrud[newclosestrecrud,1]
			215. newrecrf = commonPart + allpossiblerecrud[newclosestrecrud,2]

			# Slightly different.

			216a. seq = (commonPart + 1) : (maxMOI*(chosenlocus))							# Define a sequence of locations to check for matches.
			216b. newrecr_repeats0 = sum(recoded0[x,seq] == recoded0[x,newrecrf]) 			# Find locations where tempcoded matches...?... without matching non-numerical values.

			217a. indicies = allpossiblerecrud[newclosestrecrud,2]
			217b. newrecr_repeatsf = sum(temprecoded == temprecoded[indicies],na.rm=TRUE)	# Find the matches..?

			# Exactly the same as 141.
			likelihoodnew = mean(dvect[round(newalldistance)+1]/sapply(1:length(newallrecrf), function (z) sum(frequencies_RR[[2]][chosenlocus,1:frequencies_RR[[1]][chosenlocus]]*dvect[correction_distance_matrix[[chosenlocus]][,newallrecrf[z]]+1])),na.rm=TRUE) * repeatednew

			220a. likelihoodnew = mean(bigPhrase, na.rm=TRUE) * repeatednew
			220b. dvector = dvect[ round(newalldistance)+1 ]
			220c. seq = 1:length(newallrecrf)
			220d. function unknownProcess (lambda){
				table = frequencies_RR[[2]]
				freq_seq = 1:frequencies_RR[[1]][chosenlocus]
				table = table[chosenlocus, freq_seq]
				sub_index = correction_distance_matrix[[chosenlocus]][,newallrecrf[lambda]]+1
				dvect[sub_index]
				return table * dvect
			}

			# Again, exaclty the same as 143.
			likelihoodold = mean(dvect[round(alldistance[x,chosenlocus,])+1]/sapply(1:(maxMOI*maxMOI), function (z) sum(frequencies_RR[[2]][chosenlocus,1:frequencies_RR[[1]][chosenlocus]]*dvect[correction_distance_matrix[[chosenlocus]][,allrecrf[x,chosenlocus,z]]+1])),na.rm=TRUE) * repeatedold 

			222a. likelihoodnew = mean(bigPhrase, na.rm=TRUE) * repeatedold
			222b. dvector = dvect[ round(newalldistance)+1 ]
			222c. seq = 1:length(newallrecrf)
			222d. function unknownProcess2 (lambda){
				table = frequencies_RR[[2]]
				freq_seq = 1:frequencies_RR[[1]][chosenlocus]
				table = table[chosenlocus, freq_seq]
				sub_index = correction_distance_matrix[[chosenlocus]][,allrecrf[lambda]]+1
				dvect[sub_index]
				return table * dvect
			}

			# code I didn't translate, just for debug purposes. Might add to the debug obj if really necessary.
			if (is.na(likelihoodnew) | is.na(likelihoodold)) { # debug
				write.csv(alleles0,"alleles0.csv")
				write.csv(allelesf,"allelesf.csv")
				write.csv(hidden0,"hidden0.csv")
				write.csv(hiddenf,"hiddenf.csv")
				write.csv(dvect,"dvect.csv")
				print(chosen)
				print(chosenlocus)
				print(chosenlocus)
				print(old)
				print(new)
				print(newallele_length)
				print(tempalleles)
				write.csv(newalldistance,"newalldistance.csv")
				write.csv(alldistance,"alldistance.csv")
			}

			# All the same as we saw earlier.

			242. if (likelihoodnew  == likelihoodold) {
				243. alpha = 1										# if both num and denominator are equal (for case when both are 0..., otherwise 0/0 gives NaN)						 
			244. else
				245. alpha = likelihoodnew / likelihoodold			# Otherwise, calculate what appears to be a ratio. Why not a probability (0 to 1) ?

			248. if (z < alpha)										# switch made
				249. recoded0[x,chosen] <<- new
				250. alleles0[x,chosen] <<- newallele_length
				251. mindistance[x,chosenlocus] <<- newmindistance

				252a. seq = 1:dim(allpossiblerecrud)[1]
				252b. alldistance[x,chosenlocus,seq] <<- newalldistance

				253. allrecrf[x,chosenlocus,seq] <<- newallrecrf
				254. recr0[x,chosenlocus] <<- commonPart + allpossiblerecrud[newclosestrecrud,1]
				255. recrf[x,chosenlocus] <<- commonPart + allpossiblerecrud[newclosestrecrud,2]

				256a. seq = (commonPart + 1) : (maxMOI*(chosenlocus))
				256b. recr_repeats0[x,chosenlocus] <<- sum(recoded0[x,seq] == recoded0[x,recr0[x,chosenlocus]])

				257. recr_repeatsf[x,chosenlocus] <<- sum(recodedf[x,seq] == recodedf[x,recrf[x,chosenlocus]])















